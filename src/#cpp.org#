#+title: C++

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
** language
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
*** new/delete
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
new/delete和C的内存分配有很多区别，主要的改进在进行了很多可定制化的内容:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   * new/delete作为运算符而不是函数存在，因此可以重载来进行内存分配的定制
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   * 在new/delete对象的时候会调用分配对象的构造和析构函数
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   * new/delete对象的时候区分了new/delete和new/delete [](主要原因还是因为需要调用构造和析构函数):-)
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   * 支持放置语法，就是传入一个信息告诉分配函数希望在哪个地方进行分配
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   * 加入了异常分配失败抛出bad_alloc
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   * 提供了一种方法设置handler在分配失败的时候调用set_new_handler()
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   * 默认的new还进行检查以确信在传递地址给构造函数之前内存分配成功
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   * 允许重载全局new/delete和某个类的new/delete
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
**** new重载
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
用户可以重载new/delete来实现全局new/delete或者是某个类的new/delete.原型有下面这些
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
// #include <new>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
void* operator new(std::size_t) throw (std::bad_alloc);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
void* operator new[](std::size_t) throw (std::bad_alloc);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
void operator delete(void*) throw();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
void operator delete[](void*) throw();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
void* operator new(std::size_t, const std::nothrow_t&) throw();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
void* operator new[](std::size_t, const std::nothrow_t&) throw();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
void operator delete(void*, const std::nothrow_t&) throw();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
void operator delete[](void*, const std::nothrow_t&) throw();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
// Default placement versions of operator new.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
inline void* operator new(std::size_t, void* __p) throw() { return __p; }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
// Default placement versions of operator delete.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
inline void  operator delete  (void*, void*) throw() { }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
inline void  operator delete[](void*, void*) throw() { }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
new/delete如果作为类成员的话被重载的话，始终是静态成员，即使你不这样声明也是如此，这个事实意味着这些运算符不接受this指针。其实这也是非常容易考虑到的，new/delete本来就是来分配内存使用的。new在初始化构造之前调用，而delete是在析构函数调用之后调用，所以非静态数据成员肯定不能够被访问:-)此外new/delete是可以继承的,调用的还是基类的new/delete函数，只不过内存大小不同。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
#include <iostream>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
#include <new>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
class A{
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
 public:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  void* operator new(size_t s,int arg) throw(std::bad_alloc) {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
    std::cout << "size : " << s << ", arg : " << arg << std::endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
    return ::operator new(s);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  void* operator new(size_t s,int arg,const std::nothrow_t& nothrow){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
    std::cout << "[nothrow]size : " << s << ", arg : " << arg << std::endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
    return ::operator new(s,nothrow);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  void operator delete(void* p) {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
    ::operator delete(p);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  int x;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
};
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
class B: public A{
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  int y;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
};
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
int main(){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  A* a=new (10,std::nothrow)A();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  B* b=new (20)B();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  delete a;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  delete b;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
**** new异常规格
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
从new的异常规格可以看到，如果是普通的调用的话可能会抛出std::bad_alloc这个异常，但是原型里面还有
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
void* operator new(std::size_t, const std::nothrow_t&) throw();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
这种使用placement来通知new不抛出异常的的接口，语义是返回NULL来告诉app分配失败。要使用这个函数也非常简单
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
// #include <new>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
//  struct nothrow_t { };
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
//  extern const nothrow_t nothrow;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
void* p=new (std::nothrow) int(); // 这里std::nothrow就是std::nothrow_t的实例
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
通过函数重载来达到这个目的，这个方法值得借鉴。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
**** 内存分配失败
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
C++来提供了内存分配失败的回调函数，但是这个只能够处理全局new分配失败的情况
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  /** If you write your own error handler to be called by @c new, it must
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   *  be of this type.  */
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  typedef void (*new_handler)();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  /// Takes a replacement handler as the argument, returns the previous handler.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
  new_handler set_new_handler(new_handler) throw();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
**** operator new与new operator
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
此外在很多书籍里面会提到operator new和new operator这两个说法，这两个是不一样的概念。operator new就是我们重写运算符函数，而new operator使我们调用new这个表达式。本质上说new这个表达式调用了分配类型里面的operator new函数，同时调用这个类型的初始化构造函数。同理operator delete和delete operator差别也是一样的。通常new operator的动作是这样的:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
同理通常delete operator的动作是这样的:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
说到这里，我们需要清楚为什么需要有new []和delete []的方法了。对于operator new和delete来说真的不关心这些，因为只是分配内存，而对于new operator和delete operator就需要关心了，因为需要关心有多少个对象，这样的话才能够调用每个对象的构造函数。调用了new []分配的对象也一定需要使用delete []来释放，不然只会调用第一个元素析构函数和释放它的空间。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
*** static assert
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#define STATIC_ASSERT(_cond,_name)      typedef char STATIC_ASSERT_FAILED_ ## _name [ (_cond) ? 1 : -1 ]
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#define STATIC_SIZE_ASSERT(_type,_size) STATIC_ASSERT ( sizeof(_type)==_size, _type ## _MUST_BE_ ## _size ## _BYTES )
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
这个宏用来检测sizeof(_type)==_size这个假设，这个可以在编译代码的时候可以进行断言。好比下面这段程序
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
int main() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  STATIC_SIZE_ASSERT(int,8);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  return 0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
那么编译就会出现
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+BEGIN_EXAMPLE
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
main.cc:5: error: size of array `STATIC_ASSERT_FAILED_int_MUST_BE_8_BYTES’ is negative
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+END_EXAMPLE
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
当然错误信息并不是非常的优美，但是已经提供了足够多的信息了。不过这种编译断言可能只是比较适合用于简单断言比如sizeof等，对于复杂断言话可能还是需要依赖于configure这种工具比如系统是否有libunwind库。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
c++0x(--std=c++0x)在语言层面上支持static_assert.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
*** renew static_cast
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
学习C的时候总是认为强转不过就是二进制层面的强转。开始学习C++之后就认为C语言的强转对应的就是reinterpret_cast.而static_cast和reinterpret_cast的差别不过就是static_cast可以做一些类型上面的检查，所以在大多数的时候都习惯使用reinterpret_cast而非static_cast.直到在编写itachi（一个异步网络编程框架）的时候，才发现并不是这么回事。下面的例子是我遇到问题的一个抽象。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
**** 正确的例子
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#include <cstdio>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
struct A{
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
}; // class A
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
struct B: public A{
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  int g;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
}; // class B
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
void onComplete(A* o){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  B* pb=reinterpret_cast<B*>(o);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  printf("%p\n",&(pb->g));
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
int main() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  B b;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  onComplete(&b);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  printf("%p\n",&(b.g));
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  return 0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
运行结果是
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+BEGIN_EXAMPLE
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
[dirlt@localhost ~]$ ./a.out
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
0xbff031b0
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
0xbff031b0
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+END_EXAMPLE
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
在onComplete这里我们希望处理一个A*抽象类型。假设我们从外围上面保证传入onComplete是一个B或者是B的子类型。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
**** 当处理多继承时
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
处理B类型没有问题，但是处理B的子类型的话，那么上面代码可能就会出现问题。因为对于B子类型而言的话很可能在 *对象模型* 之前添加了一些字段，按照reintrepret_cast语义的话是直接二进制映射，字段没有虚方法所以是直接按照偏移来取的，因此可能存在问题。但是看看下面这个例子
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#include <cstdio>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
struct A{
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
}; // class A
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
struct B: public A{
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  int g;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
}; // class B
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
struct Holder{
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  int dummy;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
};
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
struct C: public Holder,
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
          public B{
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
}; // class C
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
void onComplete(A* o){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  B* pb=reinterpret_cast<B*>(o);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  printf("o:%p pb->g:%p\n",pb, &(pb->g));
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
int main() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  C c;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  onComplete(&c);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  printf("c:%p c.g:%p\n",&c, &(c.g));
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  return 0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
运行结果
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+BEGIN_EXAMPLE
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
[dirlt@localhost ~]$ ./a.out
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
o:0xbfff9aa0 pb->g:0xbfff9aa0
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
c:0xbfff9a9c c.g:0xbfff9aa0
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+END_EXAMPLE
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
问题出来了，并不像我们想的那样，pb->g和c.g的地址是一样的。但是神奇的是，o和c的地址是不一样的。这是为什么呢？原因就在于static_cast.在传参的时候，根据形参和实参之间的类型信息来进行指针的转换。 *也就是说，static_cast能够正确处理类型系统。而这点reintrepret_cast是做不到的。*
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
**** 应该怎么做
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
*因为自己也缺乏C++对象模型方面的知识，所以也没有办法从底层解释原因。* 但是结论却非常简单，就是应该尽量地执行static_cast而非reinterpret_cast. reinterpret_cast对于继承方面基本没有做任何事情，而使用static_cast的话则能够检测到类型系统，然后根据类型系统来进行正确的转换。 要是想对于static_cast有更多认识的话，需要了解C++对象模型的实现。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
下面我总结了一下各种cast应该使用的场景：
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   1. static_cast无论如何应该首先考虑使用，而且编译器在生成函数调用时候内部也是在用static_cast.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   2. reinterpret_cast只有在你确定只处理某两种final类型时候，两者之间的转换。比如在内存操作时候uint8_t*和char*之间的转换
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   3. const_cast只有在消除const以及volatile这些标记时候有用。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   4. dynamic_cast得到父类型但是不确定子类型的时候，你需要逐个尝试转换可以使用。但是如果外部存在字符串比如type这样的字段表示类型的话，那么可以直接使用static_cast.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
** runtime
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
*** local static object
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
局部静态对象在C里面初始化只允许是常数，所以这个在编译期就可以搞定。在C++里面局部静态对象允许是一个类对象，那么就涉及到类的初始化等问题，这个是在编译期搞不定的只能够在运行期解决。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#include <iostream>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
class A{
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
 public:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  A(){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
    std::cout << "A()" << std::endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
};
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
void foo(){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  static A a;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
int main(){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  foo();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
  return 0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
我们考虑局部静态对象的初始化时机。如果仅仅是在程序启动时候就初始化的话那么肯定不合适，所以肯定是在第一次调用foo时候进行初始化(这里还需要考虑多线程问题).我们可以看看这个部分汇编代码.对于a对象的话好比存在一个instance_counter初始化为0.首先判断是否初始化了，然后会调用__cxa_guard_acquire加锁然后再判断一次(double check,可以减少开销），最后使用__cxa_guard_release释放这个锁。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+BEGIN_SRC ASM
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.globl _Z3foov
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	.type	_Z3foov, @function
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
_Z3foov:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.LFB1445:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	pushq	%rbp
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.LCFI3:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	movq	%rsp, %rbp
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.LCFI4:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	subq	$32, %rsp
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.LCFI5:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	cmpb	$0, _ZGVZ3foovE1a(%rip)
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	jne	.L10
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	movl	$_ZGVZ3foovE1a, %edi
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	call	__cxa_guard_acquire
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	testl	%eax, %eax
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	je	.L10
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	movb	$0, -1(%rbp)
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	movl	$_ZZ3foovE1a, %edi
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.LEHB0:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	call	_ZN1AC1Ev
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.LEHE0:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	movl	$_ZGVZ3foovE1a, %edi
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	call	__cxa_guard_release
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	jmp	.L10
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.L19:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	movq	%rax, -24(%rbp)
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.L13:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	movq	-24(%rbp), %rax
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	movq	%rax, -16(%rbp)
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	cmpb	$0, -1(%rbp)
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	je	.L15
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	jmp	.L16
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.L15:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	movl	$_ZGVZ3foovE1a, %edi
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	call	__cxa_guard_abort
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.L16:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	movq	-16(%rbp), %rax
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	movq	%rax, -24(%rbp)
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.L17:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	movq	-24(%rbp), %rdi
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.LEHB1:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	call	_Unwind_Resume
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.LEHE1:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
.L10:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	leave
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
	ret
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
*** hook function
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
hook函数调用有两种方式，一种是hook我们代码内部的函数，这意味这这个函数是由我们来编译的，当然我们不能够修改需要hook的函数实现否则就没有意义了。另外一种hook函数是动态库里面的函数，静态库里面的函数因为完全进入了可执行程序，所以修改起来比较麻烦一些。我们QA写过这样的程序用libbfd库修改可执行程序本身，在函数调用之间加上跳板，但是相比本文介绍的两种方式更加复杂。（复杂就以为着容易出错，而且这种修改可执行程序应该是不值得提倡的）。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
*编译时hook*
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
在gcc编译的时候需要加入-finstrument-functions这个选项之后，那么每个函数调用之前和之后都会调用
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
这两个函数是gcc内置函数，_enter函数能够在函数调用之前进行调用，_exit函数能够在函数调用退出之后调用，原型分别是
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
// this是这个callee函数地址
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
// callsite是caller函数调用点地址(不是函数地址)
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
void __cyg_profile_func_enter(void *this, void *callsite);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
void __cyg_profile_func_exit(void *this, void *callsite);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
如果不希望函数被hook的话，那么可以在函数属性之后加上__attribute__((no _instrument _function)).尤其是这个函数如果在enter和exit里面调用的话，最好加上这个属性，不然非常容易出现递归调用
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#include <cstdio>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#include <cstdlib>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
void foo() __attribute__((no_instrument_function));
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
void foo() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    printf("%s\n",__func__);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
int main() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    printf("main\n");
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    return 0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
extern "C" {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    void __cyg_profile_func_enter(void* callee, void* callsite)  __attribute__((no_instrument_function));
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    void __cyg_profile_func_exit(void* callee, void* callsite) __attribute__((no_instrument_function));
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    void __cyg_profile_func_enter(void* callee, void* callsite) {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
        foo();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    void __cyg_profile_func_exit(void* callee, void* callsite){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
        foo();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
*运行时hook*
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
可以使用dlopen截获函数入口，然后使用dlsym(RTLD_NEXT)来获得下一个入口.我们以截获malloc为例。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#include <unistd.h>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#include <dlfcn.h>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#include <cstring>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#include <cstdlib>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
void* malloc(size_t size){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    write(2,"do malloc\n",strlen("do malloc\n")+1); // 这里不能够用printf,因为内部可能会调用malloc
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    static void* (*pmalloc)(size_t size)=0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    if(!pmalloc){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
        pmalloc=(void*(*)(size_t size))(dlsym(RTLD_NEXT,"malloc"));
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    return pmalloc(size);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
void free(void *p){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    write(2,"do free\n",strlen("do free\n")+1);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    static void (*pfree)(void* p)=0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    if(!pfree){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
        pfree=(void(*)(void* p))(dlsym(RTLD_NEXT,"free"));
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
    return pfree(p);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
*** undefined reference to static const class member
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
类型静态常量成员只允许是标量内容,而不允许是字符串数组或者是结构体等。但是下面代码会存在链接问题
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#include <vector>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
using namespace std;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
class Foo {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
 public:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
  static const int MEMBER = 1;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
};
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
int main(){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
  vector<int> v;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
  v.push_back( Foo::MEMBER );       // undefined reference to `Foo::MEMBER'
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
  v.push_back( (int) Foo::MEMBER ); // OK
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
  return 0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
关于这个问题解释可以参看 http://stackoverflow.com/questions/272900/c-undefined-reference-to-static-class-member
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
大致解释是这样，对于第一种用法的话，因为push_back需要是一个const int&,因为需要传入的内容存在地址。而这种情况下面MEMBER仅仅是一个constant,没有任何地址所以会出现链接错误。而对于第二种情况的话，因为强制转换之后那么就存在一个临时对象可以被引用。说到这里我们一定需要注意临时对象，好比下面这种用法
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#include <string>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
int main() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
  std::string s1="h";
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
  std::string s2="o";
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
  const char* s=(s1+s2).c_str();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
  return 0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
这里(s1+s2)生成了一个临时对象但是却没有存放的内容，所以后续继续引用s是会出问题的。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
*** malloc warmup performance
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
下面是我之前碰到的因为malloc warmup导致的性能差异巨大的问题。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
程序有两个函数，action是为了测试一下以string为key的map性能，action2是为了测试一下以int为key的map性能。然后我们分两组测试运行：
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
/* coding:utf-8
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
 * Copyright (C) dirlt
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
 */
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
#include <sys/time.h>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
#include <map>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
#include <string>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
#include <cstdio>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
using namespace std;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
static inline double gettime_ms() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  struct timeval tv;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  gettimeofday(&tv, NULL);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  return tv.tv_sec * 1000.0 + tv.tv_usec * 0.001;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
static const int NUMBER = 10000000;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
static const char* PREFIX = "s";
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
static void action() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  double start = gettime_ms();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  map<string, long> dict;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  char buf[64];
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  char buf2[64];
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  for(int i = 0; i < NUMBER; i++) {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
    snprintf(buf, sizeof(buf), "%s%d", PREFIX, i);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
    dict[buf] = i;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  for(int i = 0; i < NUMBER; i++) {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
    snprintf(buf, sizeof(buf), "%s%d", PREFIX, i);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
    snprintf(buf2, sizeof(buf2), "%s%d", PREFIX, (i + 1000) % NUMBER);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
    dict[buf] += dict[buf2];
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  double end = gettime_ms();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  printf("%.2lf\n", end - start);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
static void action2() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  double start = gettime_ms();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  map<int, long> dict;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  for(int i = 0; i < NUMBER; i++) {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
    dict[i] = i;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  for(int i = 0; i < NUMBER; i++) {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
    dict[i] += dict[(i + 1000) % NUMBER];
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  double end = gettime_ms();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  printf("%.2lf\n", end - start);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
int main() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  action();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  action2();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
  return 0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
在自己的Ubuntu机器下面使用g++4.6编译运行结果如下。可以看到测试组1里面action2运行时间为2.9s左右，而测试组2里面action2运行时间为8.5s 时间差别很大
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
#+BEGIN_EXAMPLE
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
➜  tomb git:(master) ✗ g++ map_perf_test.cc -O2
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
➜  tomb git:(master) ✗ ./a.out
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
19764.38
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
2957.30
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
➜  tomb git:(master) ✗ g++ map_perf_test.cc -O2
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
➜  tomb git:(master) ✗ ./a.out
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
8521.25
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
#+END_EXAMPLE
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
可能是编译器的原因？ 在自己的Ubuntu机器下面clang++来编译，时间差别同样很大
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
#+BEGIN_EXAMPLE
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
➜  tomb git:(master) ✗ clang++ map_perf_test.cc -O2
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
➜  tomb git:(master) ✗ ./a.out
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
19494.99
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
3052.83
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
➜  tomb git:(master) ✗ clang++ map_perf_test.cc -O2
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
➜  tomb git:(master) ✗ ./a.out
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
8495.00
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
#+END_EXAMPLE
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
在自己的macbook air下面使用clang重新编译，时间是差不多的
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
#+BEGIN_EXAMPLE
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
➜  tomb git:(master) ✗ g++ map_perf_test.cc -O2
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
➜  tomb git:(master) ✗ ./a.out
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
22759.82
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
4203.22
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
tomb git:(master) ✗ g++ map_perf_test.cc -O2
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
➜  tomb git:(master) ✗ ./a.out
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
4214.48
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
#+END_EXAMPLE
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
另外我让同事在其他机器上使用g++3.4.5编译运行，时间差别也非常大
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
多谢 @Thomas 的指导，通过strace发现确实是glibc的内存分配问题。strace两个binary发现：
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
改用 [[file:tcmalloc.org][tcmalloc]] 之后没有这个问题了。tcmalloc调用brk（541次），mmap（500次）。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
** library
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
*** boost::bind
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
之前看到陈硕同学在[[http://blog.csdn.net/solstice/][博客]] 给出的C++工程实践推荐，使用boost::function和boost::bind代替虚函数。之所以我们需要使用虚函数，无非就是希望统一执行接口。统一接口通过虚函数是一种方法，而使用boost::function和boost::bind也可以达到相同的目的。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
首先我们假设存在一个Executor类，里面有一个执行队列，所有的Task首先被push进来然后遍历执行。对于这个Task我们本身只需要一个执行接口void fun(Executor*).如果通过虚函数实现的话，我们需要定义一个abstract class含有virtual函数，然后在具体的类里面实现它。但是如果很不幸的话我们原本定义的类不是这样的，而是
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
class A{
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
 public:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
  void fun(Executor* x,std::string s){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
    std::cout << "executor=" << x << ", s=" << s << std::endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
  }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
}; // class A
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
class B{
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
 public:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
  void fun(Executor* x,int s){
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
    std::cout << "executor=" << x << ", s=" << s << std::endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
  }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
}; // class B
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
那我们必须重新定义AdapterA以及AdapterB封装一下。实现上可能非常简单，内部存下std::string以及int的内容，外加一个A,B的指针，在fun里面调用A,B的fun实现并且把内容传进去调用。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
这是一种蹩脚的方法，类的个数会急剧膨胀。但是如果我们使用boost::function和boost::bind的话，可以不用添加新的Adapter类来解决这个问题。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
  x.push(boost::bind(&A::fun,&a,_1,"hello"));
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
  x.push(boost::bind(&A::fun,&a,_1,"world"));
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
  x.push(boost::bind(&B::fun,&b,_1,123));
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
  x.push(boost::bind(&B::fun,&b,_1,456));
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
这里_1是boost::bind导出的符号表示占位符，这个参数表示接口中的第一个参数，这里不进行绑定。第一个参数表示函数地址，如果是成员函数的话那么需要传入对象地址（这里对于对象内存管理的话，可能需要智能指针的帮助。可以参考http://xuchaoqian.com/?p=797)。事实上稍微猜想一下boost::function和boost::bind实现，boost::function用于产生新的类型，boost::bind用于产生这个类型的对象，并且将指针以及所需要的closure context都绑定上去。我本来想实现的，但是发现基于模板的元编程，我确实不会:(
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
之后我在想，虽然这个方式不错消除继承完全按照基于对象的方式编程，但是如果对于对象所需要的接口非常多的话，并且虚函数本身就是语言内置的特性，相对来说使用起来会更加方便。下面是可编译的示例代码之后我在想，虽然这个方式不错消除继承完全按照基于对象的方式编程，但是如果对于对象所需要的接口非常多的话，并且虚函数本身就是语言内置的特性，相对来说使用起来会更加方便。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
具体代码可以参考 [[file:codes/cc/misc/test_bind.cc][code on github]]
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
*** boost::spirit
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
今天被Dr. Yang推荐使用boost::spirit，模板编程实现的语法解析器。Dr. Yang推荐我看看hypertable里面实现的hql，里面就是使用spirit实现的hql(hypertable query language)，在src/cc/Hypertable/Lib/HqlParser.h里面。粗看一下功能还是非常强大的，对于很多使用flex/bison完成的工作都可以通过spirit来完成。看上去是LALR解析器，现在不太清楚就是如果出现shift/reduce或者是reduce/reduce冲突的话spirit是怎么解决的。#note:应该是LL(1)解析器
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
对于action的话需要单独编写function object来完成，operator()是这个grammar对应的字符串。定义ParserState来构建语法树是一个好主意。对于里面更多的细节现在还是不太了解，关于入门使用可以查看代码中的链接或者documentation.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
具体代码可以参考 [[file:codes/cc/misc/test_spirit.cc][code on github]]
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
*** boost::property_tree
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
http://www.boost.org/doc/libs/1_58_0/doc/html/property_tree.html
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
用作配置文件不错. 具体代码可以参考 [[file:codes/cc/misc/test_ptree.cc][code on github]]
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
*** boost::python
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
http://www.boost.org/doc/libs/1_58_0/libs/python/doc/index.html
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
编写Python Extension. 具体代码可以参考 [[file:codes/cc/misc/test_pye.cc][code on github]]
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
*** logging
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
@2015-07-26 最近一段时间使用C++编写Python扩展时候，发现原来的日志库(easyloggingpp)封装存在一些问题。修改完成日志库的封装之后，顺便就看了一下C/C++下面有什么可用的日志库。我粗略地看了下面几种，然后总结了一下优缺点以及自己的想法。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
** c++11
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
C++11在C++03上做了许多改进，而且都是非常实用的改进。BS在自己的主页上列出了这些改进的 [[http://www.stroustrup.com/C++11FAQ.html][细节]], 有位国内开发者把它翻译成了 [[http://www.chenlq.net/cpp11-faq-chs][中文]] (非常感谢).
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
下面这几篇文章介绍了其中一些对于大部分C++使用者来说会更加关心的改进
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
这里我把文章里面所涉及的改进全部列了出来
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
使用<thread>必须加上编译参数-pthread.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
*suffix return type syntax(返回值类型后置语法)* 一开始我以为这个语法，是为了解决编写模板函数的时候，auto不能自动推导函数返回类型而设计的。比如下面这段程序
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
template<typename T1, typename T2>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
auto bar(const T1 a, const T2 b) -> decltype(a + b) {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
    return a + b;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
如果我们不使用"-> decltype(a+b)"这个后置语法的话，那么编译器就不知道bar应该返回什么类型。但是事实却是，编译器已经足够强大到推测返回类型了，所以我们不告诉编译器返回值类型也可以（但是会有warning）
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
实际按照BS的 [[http://www.stroustrup.com/C++11FAQ.html#suffix-return][想法]], 一开始这个语法的引入，却是为了解决作用域问题的。比如下面这段程序
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
class A {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
  public:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
    class B {};
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
    B foo();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
};
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
// A::B A::foo() { return B(); }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
auto A::foo() -> B { return B(); }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
如果我们按照第一种写法编写foo的话，返回值必须写明A::B, 因为再此之前还没有进去A作用域所以要写全名。而使用第二种写法的话，因为我们已经限定了在A作用域下，所以返回类型可以直接写B
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
*lambda expression(lambda表达式，匿名函数)*. 语法大致是这样的[capture](parameters) [suffix-return-type] { body }. 就像之前说的那样，C++11类型推导能力非常强大，所以suffix-return-type通常是可选的。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
在capture这个部分中，&v表示使用变量v的引用，=v表示使用v的copy(read-only). 如果是[&]表示所有外部变量的使用都是引用方式，如果是[=]表示所有外部变量使用都是传值方式。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
匿名函数类型是std::function<[actual-type>].(defined in <functional>). 比如[](int a, int b) { return a + b; }的类型就是std::function<int(int,int)>. 虽然匿名函数可以捕获变量，但是并不意味着实现了闭包。下面这个程序中，lambda引用了count，但是在调用的时候count已经被销毁了，所以会出现运行错误。
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
#include <functional>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
#include <iostream>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
using namespace std;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
std::function<int()> foo() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
    int count = 0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
    auto f = [&count]() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
        count += 1;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
        return count;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
    };
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
    return f;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
int main() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
    auto f = foo();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
    auto x = f();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
    // cout << x << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
这里还想说一下就是，C++11也把bind纳入stl了（smart pointers, atomic, thread这些原来都在boost的组件都纳入stl了）.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
#include <functional>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
#include <iostream>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
using namespace std;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
using std::placeholders::_1;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
using std::placeholders::_2;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
using std::placeholders::_3;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
int foo(int a, int b, int c) {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
    return a + b + c;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
int main() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
    auto f1 = bind(foo, 1, 2, _1);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
    auto f2 = bind(foo, _1, _2, 3);
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
    cout << f1(10) << ", " << f2(2,4) << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
    return 0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
*rvalue references and move semantics(右值引用以及移动语义)*. 右值引用比较奇怪的一个地方是，你可以认为它是一个非常容易挥发的东西。因为一旦你使用A&& a = foo();获得右值引用的时候，其实你已经获得了左值a（并且发生了copy ctor或者是move ctor, 这个根据是否有move ctor决定的）. 只有在move ctor或者是move assignment时候我们才能够瞬间捕获到右值引用。想要把一个左值变为右值可以使用std::move函数。下面是我的实验代码，可以加深理解
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#+BEGIN_SRC C++
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#include <cstdio>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#include <iostream>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#if (__cplusplus > 199711L)
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#define cxx0x
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#endif
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#include <memory>
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
using namespace std;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
class A {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
  public:
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    int v;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    A(): v(123) {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
        cout << "ctor" << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    A(const A& x) {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
        cout << "copy ctor" << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
        cout << &x << " -> " << this << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#ifdef cxx0x
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    A(A&& x) {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
        cout << "move ctor" << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
        cout << &x << " -> " << this << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#endif
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
};
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
// 这里增加条件语句，可以使得编译器不会直接在返回地址上开辟对象A
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
// 从而达到实验目的，否则只会调用一次ctor而不会调用copy ctor/move ctor.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
static int x = 0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
A bar() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    if (x == 0) {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
        A a;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
        cout << "inside bar: " << &a << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
        return a;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    } else {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
        return A();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    }
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    // return A();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#ifdef cxx0x
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
int foo1() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    cout << "----- foo1(test c++0x) -----" << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    A&& pa = bar();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    // 虽然这里写的是&&, 但是实际上效果等同于A pa = bar();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    // 这个pa已经在stack上分配出来了. use move ctor.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    cout << "pa = " << &pa << "/" << &(pa.v) << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    cout << "-----" << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    A pb = pa; // copy ctor.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    cout << "pb = " << &pb << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    cout << "-----" << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    A pc = std::move(pb); // move ctor.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    cout << "pc = " << &pc << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    return 0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#endif
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
int foo2() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    cout << "----- foo2(test c++03) ----" << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    // move ctor in c++0x.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    // copy ctor in c++03.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    A pa = bar();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    cout << "pa = " << &pa << "/" << &(pa.v) << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    cout << "-----" << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    A pb = pa; // copy ctor.
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    cout << "pb = " << &pb << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    return 0;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----

- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
int main() {
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#ifdef cxx0x
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    foo1();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    cout << endl << endl;
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#endif
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
    foo2();
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
}
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
#+END_SRC
- The C Programming Language(DMR & BWK)
- C and Pointers
- The C++ Programming Language(BS)
- Thinking in C++
- http://www.cplusplus.com/doc/tutorial/
- https://isocpp.org/get-started
   - void *raw=operaotor new(sizeof(A)); //使用operator new进行内存分配
   - call A::A on *raw; //在raw上面调用构造函数
   - A *a=static_castraw; //最后进行一次强制转换
   - a->~A();//调用一次析构函数
   - operator delete(a);//进行内存释放
   - __cyg_profile_func_enter
   - __cyg_profile_func_exit
- 运行action，然后运行action2
- 只运行action2
   - action调用了很多brk（8288次）,mmap（17次）来分配内存，每次都是分配小内存.运行完成之后这些内存buffer起来了。
   - 在action调用之后的action2没有调用任何系统调用分配内存，都是在用户态完成。
   - 而如果没有action先调用的话，action2就需要自己调用brk（4737次）,mmap（17次），所以比较耗时。
- https://github.com/easylogging/easyloggingpp easylogging++
  - 一个头文件，可以很容易集成
  - 设计上没有Handler, Filter, Formatter这样的概念，相对比较简单直接
  - 多个Logger之间是平级关系，没有层次关系，虽然可以共享配置
  - 内置直接输出到文件，但是不支持rotate这样操作（需要自己编写callback）
  - 可以通过添加回调来扩展打印日志方法，但是回调函数列表是全局而非单个Logger所有
  - 简单好用，容易集成，支持多模块输出，需要自己编写代码来扩展功能
- http://code.google.com/p/google-glog/ google-glog
  - 时间有限只能从 [[http://google-glog.googlecode.com/svn/trunk/doc/glog.html][官方文档]] 来了解其功能
  - glog更像是为C++程序定制的，不支持多模块输出
  - 可以选择输出到标准错误或者是文件，文件默认是在""/tmp/<program name>.<hostname>.<user name>.log.<severity level>.<date>.<time>.<pid>". 这意味着不需要考虑rotate。用户可以指定输出文件的路径但是不能修改文件名称
  - 从文档上看没有提供扩展能力（代码可能会有这个功能，但是需要用户阅读代码来扩展）
  - 对C++程序简单好用，容易集成，扩展能力比较差只支持输出文件（但是如果考虑到G还有 [[file:gwp.org][其他]] [[file:dapper.org][系统]] 来辅助日志分析的话，其实这个不是问题）
- log4cpp/log4cplus/log4cxx # log4j的C++实现.
  - 从功能上来说是最强大的，支持多模块输出，也很容易集成，只是没有那么好用
  - 设计上有Handler, Filter, Formatter这样的概念，设计考虑上非常周到
  - 网上有不少关于如何具体使用log4cxx的文章，但是很少有谈论其设计的文章。设计方面可以阅读一下 [[https://docs.python.org/3/library/logging.html?highlight=logging#module-logging][python logging]]
- Continuous Learning : C++ 11 Tutorial : http://learnandexperiment.blogspot.com/2013/07/c-11-tutorial.html
- Ten C++11 Features Every C++ Developer Should Use - CodeProject : http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer
- The Biggest Changes in C++11 (and Why You Should Care) : http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/
- auto. auto是C的关键字，表示变量空间是自动分配的（相对应的是regsiter），但是实际上几乎所有的编译器都忽略这个关键字。在C++11里面给这个关键字赋予了新的语义，就是做类型推导。
- decltype. decltype(expression)可以返回expression的类型定义。在C++03的时候，如果想获得某个表达式的类型的话，只能使用g++扩展关键字typeof(expression).
- nullptr. C++11引入的空指针关键字，类型是std::nullptr_t. nullptr可以隐式转换为任意指针类型以及bool类型，但是却不能够转换为int类型了(之前NULL本身就是#define NULL (0)).
- strongly-typed enums. C++03会把enum class 1. 定义对象导出到外部作用域（可能会出现名字冲突）2. 隐式地将枚举对象转换为整数值 3. 不创建这个枚举类型。C++11取消了这些特殊处理。
- override/final. 这两个关键字只有出现在成员函数声明最后如void foo() [...]才有用。override要解决的问题是，确保这个函数是重写(override)而不是重载(overload)子类中的某个虚函数. final则是希望某个虚函数不要被重写(override).
- default/delete. 这两个关键字同样要出现在成员函数声明之后入void foo() = [...]. 通常作用在构造函数上。default告诉编译器为这个函数生成默认实现. delete则告诉编译器删除这个函数实现（禁止拷贝或赋值构造）
- static_assert/type_traits. type_traits提供一系列template function来对类型做判断. 在C++03做静态断言static_assert需要使用workaround办法，但是在C++11就直接提供了。
- delegating constructors. 代理构造函数.
- range-based for statement. 可以使用for(auto& e: v)这种简洁的语法来编译容器
- uniform initialization syntax. 统一的初始化语法，全部使用{}来包含参数。比如构造函数是A(int a, float b)的话，可以使用A a{1, 2.3};来构造对象
- in-class member initializers. 类成员的内部初始化。类成员初始化可以不用在构造函数内完成，可以直接在类的内部完成初始化（必须是编译期可以确定的常量表达式）
- inline namespace. 内联名字空间。如果一个名字空间是inline namespace XXX定义的，并且被包含在namespace YYY里面的话，那么XXX内部成员f可以使用YYY::f引用，也可以使用YYY::XXX::f引用（可以处理代码向后兼容问题）
- initializer lists. 初始化列表。许多stl容器比如vector, map支持初始化列表，也就是说可以这样vector<int> a {1,2,3};来构造。初始化列表具体类型是std::initializer_list<E>.
- right-angle brackets. 右角括号这个问题在C++03非常恼人，就是写嵌套容器时必须这样vector<vector<A> >. C++11解决了这个问题
- 除此之外还有suffix return type syntax, rvalue reference and move semantics, lambda expression等一些改进放在后面单独说
-----
-----
- capture 是指我们需要捕获哪些外部变量
- parameters 则是匿名函数的参数列表
- body 则是匿名函数的函数体
-----
